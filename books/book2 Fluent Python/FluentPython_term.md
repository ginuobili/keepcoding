Python术语表

**CPython**
标准的Python解释器，使用C语言实现。讨论不同实现特有的行为，以及多个可用的Python解释器（如PyPy）时才会使用这个术语。

**CRUD**
Create、Read、Update、Delete的首字母缩写，这是存储记录的应用程序中的四种基本操作。

**doctest**
一个模块，其中的函数能解析并运行 Python 模块或纯文本文件的文档字符串中内嵌的示例。也可以在命令行中使用，如下所示：
`python -m doctes module_with_tests.py`

**DRY**
Don’t Repeat Yourself（不要自我重复）的缩写，一种软件工程原则，意思是：“系统中的每一项知识都必须具有单一、无歧义、权威的表示。”首先由 Andy Hunt 与 Dave Thomas 的《程序员修炼之道：从小工到专家》一书提出。

**dunder**
首尾有两条下划线的特殊方法和属性的简洁读法（即把`__len__`读成“dunder len”）。

**EAFP**
“it's easier to ask forgiveness than permission”（取得原谅比获得许可容易）的首字母缩写。人们认为这句话是计算机先驱Grace Hopper说的，Python程序员使用这个缩写指代一种动态编程方式，例如访问属性前不测试有没有属性，如果没有就捕获异常。 hasattr函数的文档字符串是这样描述它的工作方式的：“调用getattr(object,name)，然后捕获AttributeError异常。”

**genexp**
generator expression（生成器表达式）的简称。

**KISS原则**
KISS是“Keep It Simple, Stupid”的首字母缩写。这个原则要求尽量寻找最简单的方案，尽量减少可变部分。这个警句是Kelly Johnson首创的。Kelly是一位多才多艺的航空工程师，在真实存在的51区工作，设计出了20世纪最先进的几架航天飞机。

**listcomp**
list comprehension（列表推导）的简称。

**ORM**
Object-Relational Mapper（对象关系映射器）的缩写，通过这种API可以使用Python类和对象访问数据库中的表和记录，而且调用方法可以执行数据库操作。SQLAlchemy是流行的独立Python ORM，Django和Web2py自带了ORM。

**PyPI**
Python包索引，里面有超过60000个包可用。也叫奶酪店（参见奶酪店词条）。为了防止与PyPy混淆，PyPI应该读作“pie-P-eye”。

**PyPy**
Python编程语言的另一种实现，使用一个工具链把部分Python编译成机器码，因此解释器的源码其实是使用Python编写的。PyPy还提供了JIT，即时把用户的程序编译成机器码——与Java VM的作用相同。根据PyPy公布的基准测试，从2014年11月起，PyPy平均比CPython快6.8倍。为了防止与PyPI混淆， PyPy应该读作“pie-pie”。

**Pythonic**
用于赞扬符合Python风格的代码，即充分利用Python语言的特性，写出简洁明了、可读性强，通常运行速度也快的代码。还指API符合Python高手的编程方式。

**Python之禅**
从Python 2.2起，在Python控制台中输入import this后看到的输出。

**REPL**
read-eval-print loop（读取－求值－输出循环）的简称，一种交互式控制台，如标准的python或非主流的ipython和bpython，以及Python Anywhere。

**YAGNI**
You Ain't Gonna Need It（你不需要这个）的首字母缩写，这个口号的意思是，根据对未来需求的预测，不要实现非立即需要的功能。

**绑定方法（bound method）**
通过实例访问的方法会绑定到那个实例上。方法其实是描述符，访问方法时，会返回一个包装自身的对象，把方法绑定到实例上。那个对象就是绑定方法。调用绑定方法时，可以不传入self的值。例如，像`my_method=my_obj.method` 这样赋值之后，可通过`my_method()`调用绑定方法。请与非绑定方法相比较。

**编码解码器（codec）**:
（编码器/解码器）提供编码和解码函数的模块，通常在str和bytes之间转换，不过Python也提供了在bytes和bytes，以及str和str之间转换的编码解码器。

**别名（aliasing）**:
为同一个对象指定两个或多个名称。例如，在a=[]; b=a中，a和b是别名，指向同一个列表对象。对于把对象引用存储在变量中的语言来说，别名无处不在。为了避免混淆，要摒弃这种想法：变量是存储对象的盒子（毕竟同一个对象不可能放在两个盒子里）。**我们要把变量看做对象的标注（一个对象可以有多个标注）**。

**并行赋值（parallel assignment）**:
使用类似a, b=[c, d]这样的句法，把可迭代对象中的元素赋值给多个变量，也叫解构赋值。这是元组拆包的常见用途。

**抽象基类（abstract base class，ABC）**:
无法实例化，只能扩展的类。Python通过ABC实现接口。除了继承ABC之外，类还可以注册成为ABC的虚拟子类，声明自己实现了接口。

**初始化方法（initializer）**:
`__init__` 方法更贴切的名称（取代构造方法）。`__init__`方法的任务是初始化通过self参数传入的实例。实例其实是由 `__new__` 方法构建的。

**存取方法（accessor）**:
用于存取单个数据属性的方法。有些作者把存取方法当作通用术语使用，包括读值方法和设值方法；另一些作者则用存取方法指代读值方法，而用变值方法指代设值方法。

**代码异味（code smell）**:
一种代码形式，表明程序的设计可能有问题。例如，过度使用isinstance检查具体的类是一种代码异味，因为这样会导致程序以后难以扩展，无法处理新类型。

**单例（singleton）**:
一个类唯一存在的实例——这通常不是巧合，而是故意为之，防止类创建多个实例。有一种设计模式就叫单例模式，指明如何编写这样的类。在Python中，None对象是单例。

**导入时（import time）**:
Python解释器加载模块，从上到下计算，把里面的代码编译成字节码之后，开始执行模块的那一刻。类和函数在此时定义，变成真实存在的对象。装饰器也在此时执行。

**迭代器（iterator）**:
实现了无参数方法`__next__`的对象；这个方法返回级数里的下一个元素，如果没有元素了就抛出StopIteration异常。在Python中，迭代器还实现了`__iter__`方法，因此迭代器也是可迭代的对象。根据最初的设计模式，经典迭代器返回集合里的元素。生成器也是迭代器，不过更灵活。 

**生成器（generator）**：
使用生成器函数或生成器表达式构建的迭代器，无需迭代集合就可能生成值。生成斐波纳契数列的生成器是个典型示例，这是一种无穷数列，在集合中绝对放不下。这个术语除了表示调用生成器函数得到的对象之外，有时还表示生成器函数。

**生成器表达式（generator expression）**：
放在括号里的表达式，句法与列表推导一样，不过返回的不是列表，而是生成器。生成器表达式可以理解为列表推导的惰性版本。

**生成器函数（generator function）**：
放在括号里的表达式，句法与列表推导一样，不过返回的不是列表，而是生成器。生成器表达式可以理解为列表推导的惰性版本。

**惰性求值（lazy）**:
指可迭代的对象按需生成元素。在Python中，生成器会惰性求值。

**二进制序列（binary sequence）**:
一个通用术语，表示元素是二进制数据的序列类型。内置的二进制序列类型有byte、bytearray和memoryview。

**泛函数（generic function）**:
以不同的方式为不同类型的对象实现相同操作的一组函数。从Python 3.4起，创建泛函数的标准方式是使用`functools.singledispatch`装饰器。在其他语言中，这叫多分派方法。

**非绑定方法（unbound method）**:
直接通过类访问的实例方法没有绑定到特定的实例上，因此把这种方法称为“非绑定方法”。若想成功调用非绑定方法，必须显式传入类的实例作为第一个参数。那个实例会赋值给方法的self参数。参见绑定方法词条。

**描述符（descriptor）**：
一个类，实现`__get__`、`__set__` 和 `__delete__` 特殊方法中的一个或多个，其实例作为另一个类（托管类）的类属性。描述符管理托管类中托管属性的存取和删除，数据通常存储在托管实例中。

**非覆盖型描述符（nonoverriding descriptor）**:
未实现`__set__`方法的描述符，不干涉托管实例中托管属性的设置。因此，托管实例中的同名属性会遮盖实例中的描述符。也叫非数据描述符或遮盖型描述符。请与覆盖型描述符相比较。

**覆盖型描述符（overriding descriptor）**:
实现了`__set__`方法的描述符，设置托管实例中的托管属性时会遭到拦截并覆盖相关操作。也叫数据描述符或强制描述符。请与非覆盖型描述符相比较。

**高阶函数（higher-order function）**:
以其他函数为参数的函数，例如sorted、map和filter；或者，返回值为函数的函数，例如Python中的装饰器。

**构造方法（constructor）**:
类的`__init__`实例方法称为类的构造方法，因为这个方法的语义类似于Java中的构造方法。然而，这样称呼并不规范，`__init__`更应该称为初始化方法，因为它并不会构建实例，而是把实例传给self参数。Python在`__init__`方法之前调用的`__new__`类方法更合乎构造方法这个术语，`__new__`方法才会创建实例并将其返回。参见初始化方法词条。

**函数（function）**:
严格来说，是指 def 块或 lambda 表达式计算得到的对象。通常，函数这个词用于表示任何可调用的对象，例如方法，有时甚至表示类。官方文档中的内置函数列表列出了几个内置的类，例如dict、range和str。另见可调用的对象词条。

**猴子补丁（monkey patching）**:
在运行时动态修改模块、类或函数，通常是添加功能或修正缺陷。猴子补丁在内存中发挥作用，不会修改源码，因此只对当前运行的程序实例有效。因为猴子补丁破坏了封装，而且容易导致程序与补丁代码的实现细节紧密耦合，所以被视为临时的变通方案，不是集成代码的推荐方式。

**混入方法（mixin method）**:
抽象基类或混入类中方法的具体实现。

**混入类（mixin class）**:
用于随着多重继承类树中的一个或多个类一起扩展的类。混入类绝不能实例化，它的具体子类也应该是其他非混入类的子类。

**活性（liveness）**:
异步系统、线程系统或分布式系统在“期待的事情终于发生”（即虽然期待的计算不会立即发生，但最终会完成）时展现出来的特性叫活性。如果系统死锁了，活性也就没有了。

**及早求值（eager）**:
指可迭代对象一次构建好全部元素。在Python中，列表推导会及早求值。请与惰性求值相比较。

**集合（collection）**:
泛指由元素组成，可以单独访问各个元素的数据结构。有些集合可以包含任意类型的对象（参见容器词条），有些则只能包含一种原子类型的对象（参见平坦序列词条）。list和bytes都是集合，只不过list是容器，而bytes是平坦序列。

**假值（falsy）**:
只要bool(x)返回False，x就是假值。需要布尔值时，Python会隐式使用bool计算对象，例如控制if和while循环的表达式。与此相对的是真值（truthy）。

**尽早失败（fail-fast）**:
一种系统设计方式，建议应该尽早报告错误。Python比其他大多数动态编程语言更遵守这一原则。例如，Python中没有“未定义”的值：在初始化之前引用变量会报错；如果k不存在，my_dict[k]会抛出异常（JavaScript则不然）。还有一例：在Python中通过元组拆包做并行赋值，必须显式处理元组的每一个元素才行；而在Ruby中，如果=两边的元素数量不一致，右边未用到的元素会被忽略，或者把nil赋给左边多余的变量。

**可迭代的（iterable）**:
使用内置的iter函数可以从中获得迭代器的对象。可迭代的对象为for循环、列表推导和元组拆包提供元素。如果对象的`__iter__`方法能返回迭代器，这就是可迭代的对象。序列都是可迭代的对象；此外，实现`__getitem__` 方法的对象也是可迭代的对象。

**可散列的（hashable）**:
在散列值永不改变，且如果`a==b`，那么`hash(a)==hash(b)`也是True的情况下，如果对象既有`__hash__`方法，也有`__eq__`方法，那么这样的对象称为可散列的对象。在内置的类型中，大多数不可变的类型都是可散列的；但是，仅当元组的每一个元素都是可散列的时，元组才是可散列的。

**可调用的对象（callable object）**：
可以使用调用运算符（）调用，能返回结果或执行某项操作的对象。在Python中，可调用的对象有七种：用户定义的函数、内置的函数、内置的方法、实例方法、生成器函数、类，还有实现特殊方法`__call__`的类的实例。

**类型（type）**:
程序中的各种数据，限定可取的值和可对数据做的操作。有些Python类型近似于机器数据类型（例如float和bytes），而另一些则是机器数据类型的扩展（例如，int不受CPU字长的限制，str包含多字节Unicode数据码位）和特别高层的抽象（例如dict、 deque，等等）。类型分为两类：用户定义的类型和解释器内置的类型。在Python2.2统一类型和类之前，类型和类是不同的实体，用户定义的类不能扩展内置的类型。而在那之后，内置的类型和新式类兼容了，类是type的实例。在Python 3中，所有类都是新式类。

**列表推导（list comprehension）**:
放在方括号里的表达式，使用关键字for和in，通过处理和过滤一个或多个可迭代对象里的元素构建列表。列表推导会及早求值。

**码位（code point）**：
介于0~0x10FFFF之间的整数，用于标识Unicode字符数据库中的字符。截至Unicode 7.0，所有码位中只有不到3%指定了字符。在Python文档中，这个术语可能拼成一个词，也可能拼成两个词。例如，在Python标准库参考手册的“2. Built-in Functions”一章中，说char函数的参数是一个整数“码位”（codepoint），却说作用相反的ord函数返回一个“Unicode码位”（Unicode code point）。

**名称改写（name mangling）**:
Python解释器在运行时自动把私有属性`__x`重命名为`_MyClass__x`。

**内置函数（built-in function，BIF）**:
随Python解释器一起提供的函数，使用底层实现语言（也就是说，CPython用C语言， Jython用Java，以此类推）编写。这个术语通常指代无需导入就能使用的函数，参见Python标准库参考手册中的“2. Built-in Functions”一章。不过，内置的模块（如sys、math、re等）也包含内置函数。

**平坦序列（flat sequence）**:
这种序列类型存储的是元素的值本身，而不是其他对象的引用。内置的类型中， str、bytes、bytearray、memoryview 和 array.array 是平坦序列；而list、tuple和collections.deque是容器序列。容器：包含其他对象引用的对象。

**切片（slicing）**:
使用切片表示法生成序列的子集，例如my_sequence[2:6]。切片经常复制数据，生成新对象；然而，my_sequence[:]是对整个序列的浅复制。不过，memoryview对象的切片虽是一个memoryview新对象，但会与源对象共享数据。

**弱引用（weak reference）**：
一种特殊的对象引用方式，不计入指示对象的引用计数。弱引用使用 weakref 模块里的某个函数和数据结构创建。

**指示对象（referent）**：
引用的目标对象。谈及弱引用时最常使用这个术语。

**上下文管理器（context manager）**：
实现了 `__enter__` 和 `__exit__` 特殊方法的对象，在with块中使用。

**蛇底式（snake_case）**:
标识符的一种命名约定，使用下划线（_）连接单词，例如run_until_complete。PEP-8把这种风格称为“使用下划线分隔的小写单词”，建议用于命名函数、方法、参数和变量。PEP-8建议包名直接把各个单词拼接起来，不使用分隔符。Python标准库中有很多使用蛇底式命名的标识符，不过也有单词之间没有分隔的标识符（例如，getattr、classmethod、isinstance、str.endswith，等等）。

**驼峰式（CamelCase）**：
驼峰式（CamelCase）标识符的一种命名约定，单词的首字母大写，然后连接起来（例如ConnectionRefusedError）。PEP-8建议类名使用驼峰式，但是Python标准库没有遵守这个建议。

**深复制（deep copy）**:
复制对象时把对象的所有属性一起复制。

**视图（view）**：
在Python 3中，视图是一种特殊的数据结构，由字典的 `.keys()`、`.values()` 和 `.items()` 方法返回，作用是在不重复数据的前提下，提供字典的键和值的动态视图。在Python 2中，那些方法返回的是列表。字典视图都是可迭代的对象，支持in运算符。此外，如果视图引用的元素都是可散列的对象，那么视图还实现了`collections.abc.Set`接口。`.keys()`方法返回的视图都是这样；对 `.items()`方法返回的视图来说，如果其中的值都是可散列的对象，那么也是如此。

**属性（attribute）**：
在Python中，方法和数据属性（即Java术语中的“字段”）都是属性。方法也是属性，只不过恰好是可调用的对象（通常是函数，但也不一定）。

**统一访问原则（uniform access principle）**：
Eiffel语言之父Bertrand Meyer写道：“不管服务是由存储还是计算实现的，一个模块提供的所有服务都应该通过统一的方式使用。”在Python中，可以使用特性和描述符实现统一访问原则。由于没有new运算符，函数调用和对象实例化看起来相似，这也体现了这一原则：调用方无需知道被调用的对象是类、函数，还是其他可调用的对象。

**储存属性（storage attribute）**:
托管实例中的属性，用于存储由描述符管理的属性的值。

**托管类（managed class）**：
使用描述符对象管理类中某个属性的类。

**托管属性（managed attribute）**：
由描述符对象管理的公开属性。虽然托管属性在托管类中定义，但是作用相当于实例属性（即各个实例通常有各自的值，存储在储存属性中）。

**文档字符串（docstring）**：
documentation string的简称。如果模块、类或函数的第一个语句是字符串字面量，那个字符串会当作所在对象的文档字符串，解释器把那个字符串存储在对象的 `__doc__` 属性中。

**像文件的对象（file-like object）**:
官方文档使用的一个非正式称呼，指代实现了文件协议的对象，有read、write和close等方法。常见的变体有：逐行读写，包含编码字符串的纯文本文件；作为保存在内存中的纯文本文件的StringIO实例；包含未编码的字节的二进制文件。最后一种可能有缓冲，也可能没有缓冲。从Python 2.6起，这些标准文件类型的抽象基类在io模块里。

**像字节的对象（bytes-like object）**:
泛指字节序列。最常见的像字节的类型有bytes、bytearray和memoryview；不过，支持低层CPython缓冲协议的对象，如果元素是单个字节，那么也属于此类。

**协程（coroutine）**:
用于并发编程的生成器，从调度程序，或者通过 `coro.send(value)`方法从事件循环中接收值。这个术语可以表示通过调用生成器函数获得的生成器函数或生成器对象。 

**虚拟子类（virtual subclass）**:
不继承自超类，而是使用 `TheSuperClass.register(TheSubClass)` 注册的类。

**序列（sequence）**:
泛指长度（例如，len(s)）固定，可以使用从零开始的整数索引（例如s[0]）获取元素的数据结构。Python出现伊始，序列这个词就存在了，不过直到Python 2.6才由collections.abc.Sequence确定为一个抽象类。

**序列化（serialization）**:
把对象在内存中的结构转换成便于存储或传输的二进制或文本格式，而且以后可以在同一个系统或不同的系统中重建对象的副本。pickle模块能把任何Python对象序列化成二进制格式。

**鸭子类型（duck typing）**:
多态的一种形式，在这种形式中，不管对象属于哪个类，也不管声明的具体接口是什么，只要对象实现了相应的方法，函数就可以在对象上执行操作。

**一等函数（first-class function）**:
在语言中属于一等对象的函数（即**能在运行时创建，赋值给变量，当作参数传入，以及作为另一个函数的返回值**）。Python中的函数都是一等函数。

**引用计数（refcount）**:
CPython内部对各个对象的引用计数，用于确定垃圾回收程序何时销毁对象。

**用户定义的（user-defined）**:
在Python文档中，用户这个词几乎都是指我和你，即使用Python语言的程序员。用户与实现Python解释器的开发者是相对的。因此，“用户定义的类”表示使用Python编写的类，而不是使用C语言编写的内置类，如str。

**预激（prime，动词）**:
在协程上调用`next(coro)`，让协程向前运行到第一个yield表达式，准备好从后续的 `coro.send(value)` 调用中接收值。

**元编程（metaprogramming）**:
编写的程序使用程序的运行时信息改变程序的行为。例如，ORM可能会内省模型类的声明，确定如何验证数据库记录里的字段，以及如何把数据库类型转换成Python类型。

**元类（metaclass）**:
实例为类的类。默认情况下，Python中的类是type类的实例；例如，type(int)得到的结果是type类，因此type是元类。用户可以通过扩展type类定义元类。

**元组拆包（tuple unpacking）**:
把可迭代对象中的元素赋值给多个变量（例如，first, second, third==my_list）。Python高手通常使用这个术语，不过也有人使用可迭代对象的拆包。

**装饰器（decorator）**：
一个可调用的对象A，返回另一个可调用的对象B，在可调用的对象C的定义体之前使用句法@A调用。Python解释器读取这样的代码时，会调用A(C)，把返回的B绑定给之前赋予C的变量，也就是把C的定义体换成B。如果目标可调用对象C是函数，那么A是函数装饰器；如果C是类，那么A是类装饰器。

